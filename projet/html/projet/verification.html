<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>projet.verification API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>projet.verification</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import numpy as np 
import os
from datetime import datetime, timedelta
from collections import defaultdict
from tabulate import tabulate
import csv 
from loader import Loader
from calculation import Calculation

def remove_zscore_key_word(item :str):
            keyword = &#39;z_score_&#39;
            return item.replace(keyword,&#39;&#39;)

class Verification: 
    def __init__(self, directory) -&gt; None:
        self.directory = None 
        self.results_directory = None
        self.site_id = None
        assert directory is not None, &#34;Directory is none so we cannot affect the directory to the class&#34;
        directory = directory.strip()
        if os.path.dirname(directory) != &#34;data&#34;:
            directory = os.path.join(&#34;data&#34;, directory)
        if os.path.isdir(directory): 
            self.directory = directory
        else:
            raise ValueError (f&#34;The directory entered ({directory}) isn&#39;t a directory&#34;) 
        self.site_id = os.path.basename(directory)
        assert os.path.isdir(f&#39;{self.directory}/results&#39;), &#34;The selected directory doesn&#39;t have any results&#34;
        self.results_directory = f&#39;{self.directory}/results&#39;

    def day_mean_zscore_verification(self,date,seuil = 3):
        &#34;&#34;&#34;For a selected date, verifies the result file associated and return all the dates with a zscore lesser than -2 and -3 on any of the columns. This method should be used after simple verification  

        Args:
            date (dataframe.date): return 2 elemets : The first element is the list of all the data that has a zscore lower than 2 which corresponds to a medium level of anoamlie. The second element concerns all the data that has a zscore worst than -3 which corresponds to an anormal  data entry 
        &#34;&#34;&#34;
        
        results_data = Loader(self.directory).day_mean_result(date)
        zscore_columns = [&#39;z_score_revenue&#39;,
       &#39;z_score_auctions&#39;, &#39;z_score_impressions&#39;]

        anomalies = {}
        

        for column in zscore_columns:
            indices = results_data.index[results_data[column] &lt; -seuil].tolist()
            anomalies[column] =  list(set(indices))
            

        
        return anomalies

    def day_z_score_verification(self, data: pd.DataFrame, seuil):
        zscore_columns = [&#39;z_score_revenue&#39;,
       &#39;z_score_auctions&#39;, &#39;z_score_impressions&#39;]

        anomalies = {}
     
        for column in zscore_columns:
            indices = data.index[data[column] &lt; -seuil].tolist()
            indices = [item.strftime(&#39;%H:%M:%S&#39;) for item in indices]
            anomalies[column] =  list(set(indices))

    
        return anomalies
        
            

    def day_following_timestamps(self,timestamp_dict: dict):

        all_first_anomalie_dict = {}
        for key, value in timestamp_dict.items():
            following_times = defaultdict(int)
            first_anomalie_dict = {}
            skip_list = set()
            first_main = []

            value = [datetime.strptime(item, &#39;%H:%M:%S&#39;) for item in value]
        

            for timestamp in value:
                delay = 0
                while (timestamp + timedelta(minutes=delay)) in value:
                    delay +=  1

                
                following_times[timestamp.time()] = delay-1 #Subtract 1 beacause delay start at 0 so if an anomalie is detected but the the next value isn&#39;t an anomalie, delay == 1 but following_times should be 0
            results_dict = sorted(following_times.items())
            for index, row in results_dict:
                if index not in first_main:
                    index_datetime = datetime.combine(datetime.min, index)
                    if index_datetime not in skip_list:
                        first_main.append(index)
                        first_anomalie_dict[index] = row
                    skip_list.update(datetime.combine(datetime.min, index) + timedelta(minutes=i) for i in range(1, row + 1))

            all_first_anomalie_dict[key] = first_anomalie_dict
            
        return all_first_anomalie_dict 


    def day_anomalie_slope(self, date, seuil):
        z_columns_slopes = {}
        day_data = Loader(self.directory).data_for_day(date)
        zscore_calculation_data = Calculation(self.directory).zscore_verification(day_data)
        index_list = zscore_calculation_data.index.tolist()
        index_list.sort()
        errors = self.day_z_score_verification(zscore_calculation_data,seuil)
        anomalies = self.day_following_timestamps(errors)
        anomalie_slope = {}
        error_dict = {}
        for key, data_anomalie in anomalies.items():
            anomalie_dates = data_anomalie.keys()
            anomalie_dates = [time_index.strftime(&#39;%H:%M:%S&#39;) for time_index in anomalie_dates]
            for anomalie_date in anomalie_dates:  
                if isinstance(anomalie_date, str):
                    anomalie_date = datetime.strptime(anomalie_date, &#39;%H:%M:%S&#39;).time() 
                current_index_position = index_list.index(anomalie_date)
                current_index = index_list[current_index_position]
                previous_index = index_list[current_index_position - 1] if current_index_position &gt; 0 else None
                assert previous_index != None, f&#39;There is no previous index for this data {index_list[current_index_position - 1]}&#39;
                drop = (day_data.loc[previous_index,remove_zscore_key_word(key)] - day_data.loc[current_index,remove_zscore_key_word(key)])  / day_data.loc[previous_index,remove_zscore_key_word(key)] * 100
              
                anomalie_slope[index_list[current_index_position]] = drop
            z_columns_slopes[key]= anomalie_slope
            anomalie_slope= {}
        return z_columns_slopes
        

        
    def day_mean_anomalie_slope(self, date, seuil):
        z_columns_slopes = {}
        results_data = Loader(self.directory).day_mean_result(date)
        index_list = results_data.index.tolist()
        index_list.sort()
        errors =self.day_mean_zscore_verification(date, seuil)
        anomalies = self.day_following_timestamps(errors)
        anomalie_slope = {}
        error_dict = {}
        for key, data_anomalie in anomalies.items():
            anomalie_dates = data_anomalie.keys()
            anomalie_dates = [time_index.strftime(&#39;%H:%M:%S&#39;) for time_index in anomalie_dates]
            
            for anomalie_date in anomalie_dates:
                current_index_position = index_list.index(anomalie_date)
                current_index = index_list[current_index_position]
                previous_index = index_list[current_index_position - 1] if current_index_position &gt; 0 else None

                if current_index_position == 0: 
                    drop = 0
                else:
                #assert previous_index != None, &#39;There is no previous index for this data&#39;
                    drop = (-results_data.loc[previous_index,remove_zscore_key_word(key)] + results_data.loc[current_index,remove_zscore_key_word(key)])  / results_data.loc[previous_index,remove_zscore_key_word(key)] * 100
                anomalie_slope[index_list[current_index_position]] = drop
                &#39;&#39;&#39;
                down_value = True
                
                index_delay = 0
                while down_value:
                    
                    index_delay +=1
                    previous_index = index_list[current_index_position - index_delay] if current_index_position &gt; 0 else None
                    if(previous_index == None):
                        down_value = False
                        break
                    else:  
                        
                        current_index = index_list[current_index_position - (index_delay-1)]
                      

                        if results_data.loc[previous_index, key] &gt; results_data.loc[current_index, key]:
                            error_dict[current_index] = results_data.loc[current_index, remove_zscore_key_word(key)] - results_data.loc[previous_index, remove_zscore_key_word(key)]
                            
                        else:
                            down_value= False
                            anomalie_slope[index_list[current_index_position]] = error_dict
                          

            &#39;&#39;&#39;
            z_columns_slopes[key]= anomalie_slope
            anomalie_slope= {}
        return z_columns_slopes
        
            
    def convert_time_to_str(self,time_obj):
        return time_obj.strftime(&#39;%H:%M:%S&#39;)

    def following_error_drop_dict(self,following,previous_data):
        result_dict = {}
        for key in following.keys():
            result_dict[key] = {}
            for time_key, value in following[key].items():
                str_time_key = self.convert_time_to_str(time_key)
                result_dict[key][str_time_key] = {&#39;previous&#39;: value}

            for time_key, value in previous_data[key].items():
                if isinstance(time_key, str) == False: 
                    time_key = self.convert_time_to_str(time_key)
                str_time_key = time_key
                if str_time_key not in result_dict[key]:
                    result_dict[key][str_time_key] = {}
                result_dict[key][str_time_key][&#39;drop&#39;] = value
        return result_dict
        
    def save_following_drop_csv(result_dict):
         for key, data in result_dict.items():
            csv_filename = f&#34;{key}_data.csv&#34;
            with open(csv_filename, &#39;w&#39;, newline=&#39;&#39;) as csvfile:
                fieldnames = [&#39;time&#39;, &#39;previous&#39;, &#39;drop&#39;]
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()

                for time_key, values in data.items():
                    writer.writerow({
                        &#39;time&#39;: time_key,
                        &#39;previous&#39;: values.get(&#39;previous&#39;, &#39;&#39;),
                        &#39;drop&#39;: values.get(&#39;drop&#39;, &#39;&#39;)
                    })

            print(f&#34;CSV file &#39;{csv_filename}&#39; created successfully.&#34;)

       
    def add_minutes_to_time(self,input_time_str, delta_minutes):
        input_time = datetime.strptime(input_time_str, &#39;%H:%M:%S&#39;)
        result_time = input_time + timedelta(minutes=delta_minutes)
        result_time_str = result_time.strftime(&#39;%H:%M:%S&#39;)

        return result_time_str 

    def day_analyze_and_print_results(self, directory, time, seuil):
        day_data = Loader(directory).data_for_day(time)
        results_data = Calculation(directory).zscore_verification(day_data)
        
        abnormal = self.day_z_score_verification(results_data, seuil)
        following = self.day_following_timestamps(abnormal)
        previous_data = self.day_anomalie_slope(time, seuil)

        # Concatenate dictionaries with the desired format
        result_dict = self.following_error_drop_dict(following, previous_data)
        self.prettier_following_drop(result_dict)

    def day_mean_analyze_and_print_results(self, time, seuil):
        abnormal =self.day_mean_zscore_verification(time, seuil)
        following = self.day_following_timestamps(abnormal)
        previous_data = self.day_mean_anomalie_slope(time,seuil)
        result_dict = self.following_error_drop_dict(following, previous_data)
        self.prettier_following_drop(result_dict)
        
        
    def prettier_following_drop(self,result_dict):
        for key, data in result_dict.items():
            print(f&#34;\n{key} data:&#34;)
            print(&#34;{:&lt;12} {:&lt;10} {:&lt;10} {:&lt;10}&#34;.format(&#39;Time&#39;, &#39;End_time&#39; ,&#39;Previous&#39;, &#39;Drop&#39;))
            for time_key, values in data.items():
                print(&#34;{:&lt;12} {:&lt;10} {:&lt;10} {:&lt;10}&#34;.format(
                    time_key, self.add_minutes_to_time(time_key, values.get(&#39;previous&#39;, &#39;&#39;) ) , values.get(&#39;previous&#39;, &#39;&#39;), values.get(&#39;drop&#39;, &#39;&#39;)
                ))


               
if __name__ == &#34;__main__&#34;:
    directory = &#39;data/3ee1bd1f-01d8-4277-929d-53b1cebe457b&#39;
    time = &#34;2023-09-29&#34;
    ver = Verification(directory)
    seuil = 2
    
    mean =False 
    if mean: 
        ver.day_mean_analyze_and_print_results(time,seuil)
    else:    
        ver.day_analyze_and_print_results(directory,time,seuil)
    
   
    
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="projet.verification.remove_zscore_key_word"><code class="name flex">
<span>def <span class="ident">remove_zscore_key_word</span></span>(<span>item: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_zscore_key_word(item :str):
            keyword = &#39;z_score_&#39;
            return item.replace(keyword,&#39;&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="projet.verification.Verification"><code class="flex name class">
<span>class <span class="ident">Verification</span></span>
<span>(</span><span>directory)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Verification: 
    def __init__(self, directory) -&gt; None:
        self.directory = None 
        self.results_directory = None
        self.site_id = None
        assert directory is not None, &#34;Directory is none so we cannot affect the directory to the class&#34;
        directory = directory.strip()
        if os.path.dirname(directory) != &#34;data&#34;:
            directory = os.path.join(&#34;data&#34;, directory)
        if os.path.isdir(directory): 
            self.directory = directory
        else:
            raise ValueError (f&#34;The directory entered ({directory}) isn&#39;t a directory&#34;) 
        self.site_id = os.path.basename(directory)
        assert os.path.isdir(f&#39;{self.directory}/results&#39;), &#34;The selected directory doesn&#39;t have any results&#34;
        self.results_directory = f&#39;{self.directory}/results&#39;

    def day_mean_zscore_verification(self,date,seuil = 3):
        &#34;&#34;&#34;For a selected date, verifies the result file associated and return all the dates with a zscore lesser than -2 and -3 on any of the columns. This method should be used after simple verification  

        Args:
            date (dataframe.date): return 2 elemets : The first element is the list of all the data that has a zscore lower than 2 which corresponds to a medium level of anoamlie. The second element concerns all the data that has a zscore worst than -3 which corresponds to an anormal  data entry 
        &#34;&#34;&#34;
        
        results_data = Loader(self.directory).day_mean_result(date)
        zscore_columns = [&#39;z_score_revenue&#39;,
       &#39;z_score_auctions&#39;, &#39;z_score_impressions&#39;]

        anomalies = {}
        

        for column in zscore_columns:
            indices = results_data.index[results_data[column] &lt; -seuil].tolist()
            anomalies[column] =  list(set(indices))
            

        
        return anomalies

    def day_z_score_verification(self, data: pd.DataFrame, seuil):
        zscore_columns = [&#39;z_score_revenue&#39;,
       &#39;z_score_auctions&#39;, &#39;z_score_impressions&#39;]

        anomalies = {}
     
        for column in zscore_columns:
            indices = data.index[data[column] &lt; -seuil].tolist()
            indices = [item.strftime(&#39;%H:%M:%S&#39;) for item in indices]
            anomalies[column] =  list(set(indices))

    
        return anomalies
        
            

    def day_following_timestamps(self,timestamp_dict: dict):

        all_first_anomalie_dict = {}
        for key, value in timestamp_dict.items():
            following_times = defaultdict(int)
            first_anomalie_dict = {}
            skip_list = set()
            first_main = []

            value = [datetime.strptime(item, &#39;%H:%M:%S&#39;) for item in value]
        

            for timestamp in value:
                delay = 0
                while (timestamp + timedelta(minutes=delay)) in value:
                    delay +=  1

                
                following_times[timestamp.time()] = delay-1 #Subtract 1 beacause delay start at 0 so if an anomalie is detected but the the next value isn&#39;t an anomalie, delay == 1 but following_times should be 0
            results_dict = sorted(following_times.items())
            for index, row in results_dict:
                if index not in first_main:
                    index_datetime = datetime.combine(datetime.min, index)
                    if index_datetime not in skip_list:
                        first_main.append(index)
                        first_anomalie_dict[index] = row
                    skip_list.update(datetime.combine(datetime.min, index) + timedelta(minutes=i) for i in range(1, row + 1))

            all_first_anomalie_dict[key] = first_anomalie_dict
            
        return all_first_anomalie_dict 


    def day_anomalie_slope(self, date, seuil):
        z_columns_slopes = {}
        day_data = Loader(self.directory).data_for_day(date)
        zscore_calculation_data = Calculation(self.directory).zscore_verification(day_data)
        index_list = zscore_calculation_data.index.tolist()
        index_list.sort()
        errors = self.day_z_score_verification(zscore_calculation_data,seuil)
        anomalies = self.day_following_timestamps(errors)
        anomalie_slope = {}
        error_dict = {}
        for key, data_anomalie in anomalies.items():
            anomalie_dates = data_anomalie.keys()
            anomalie_dates = [time_index.strftime(&#39;%H:%M:%S&#39;) for time_index in anomalie_dates]
            for anomalie_date in anomalie_dates:  
                if isinstance(anomalie_date, str):
                    anomalie_date = datetime.strptime(anomalie_date, &#39;%H:%M:%S&#39;).time() 
                current_index_position = index_list.index(anomalie_date)
                current_index = index_list[current_index_position]
                previous_index = index_list[current_index_position - 1] if current_index_position &gt; 0 else None
                assert previous_index != None, f&#39;There is no previous index for this data {index_list[current_index_position - 1]}&#39;
                drop = (day_data.loc[previous_index,remove_zscore_key_word(key)] - day_data.loc[current_index,remove_zscore_key_word(key)])  / day_data.loc[previous_index,remove_zscore_key_word(key)] * 100
              
                anomalie_slope[index_list[current_index_position]] = drop
            z_columns_slopes[key]= anomalie_slope
            anomalie_slope= {}
        return z_columns_slopes
        

        
    def day_mean_anomalie_slope(self, date, seuil):
        z_columns_slopes = {}
        results_data = Loader(self.directory).day_mean_result(date)
        index_list = results_data.index.tolist()
        index_list.sort()
        errors =self.day_mean_zscore_verification(date, seuil)
        anomalies = self.day_following_timestamps(errors)
        anomalie_slope = {}
        error_dict = {}
        for key, data_anomalie in anomalies.items():
            anomalie_dates = data_anomalie.keys()
            anomalie_dates = [time_index.strftime(&#39;%H:%M:%S&#39;) for time_index in anomalie_dates]
            
            for anomalie_date in anomalie_dates:
                current_index_position = index_list.index(anomalie_date)
                current_index = index_list[current_index_position]
                previous_index = index_list[current_index_position - 1] if current_index_position &gt; 0 else None

                if current_index_position == 0: 
                    drop = 0
                else:
                #assert previous_index != None, &#39;There is no previous index for this data&#39;
                    drop = (-results_data.loc[previous_index,remove_zscore_key_word(key)] + results_data.loc[current_index,remove_zscore_key_word(key)])  / results_data.loc[previous_index,remove_zscore_key_word(key)] * 100
                anomalie_slope[index_list[current_index_position]] = drop
                &#39;&#39;&#39;
                down_value = True
                
                index_delay = 0
                while down_value:
                    
                    index_delay +=1
                    previous_index = index_list[current_index_position - index_delay] if current_index_position &gt; 0 else None
                    if(previous_index == None):
                        down_value = False
                        break
                    else:  
                        
                        current_index = index_list[current_index_position - (index_delay-1)]
                      

                        if results_data.loc[previous_index, key] &gt; results_data.loc[current_index, key]:
                            error_dict[current_index] = results_data.loc[current_index, remove_zscore_key_word(key)] - results_data.loc[previous_index, remove_zscore_key_word(key)]
                            
                        else:
                            down_value= False
                            anomalie_slope[index_list[current_index_position]] = error_dict
                          

            &#39;&#39;&#39;
            z_columns_slopes[key]= anomalie_slope
            anomalie_slope= {}
        return z_columns_slopes
        
            
    def convert_time_to_str(self,time_obj):
        return time_obj.strftime(&#39;%H:%M:%S&#39;)

    def following_error_drop_dict(self,following,previous_data):
        result_dict = {}
        for key in following.keys():
            result_dict[key] = {}
            for time_key, value in following[key].items():
                str_time_key = self.convert_time_to_str(time_key)
                result_dict[key][str_time_key] = {&#39;previous&#39;: value}

            for time_key, value in previous_data[key].items():
                if isinstance(time_key, str) == False: 
                    time_key = self.convert_time_to_str(time_key)
                str_time_key = time_key
                if str_time_key not in result_dict[key]:
                    result_dict[key][str_time_key] = {}
                result_dict[key][str_time_key][&#39;drop&#39;] = value
        return result_dict
        
    def save_following_drop_csv(result_dict):
         for key, data in result_dict.items():
            csv_filename = f&#34;{key}_data.csv&#34;
            with open(csv_filename, &#39;w&#39;, newline=&#39;&#39;) as csvfile:
                fieldnames = [&#39;time&#39;, &#39;previous&#39;, &#39;drop&#39;]
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()

                for time_key, values in data.items():
                    writer.writerow({
                        &#39;time&#39;: time_key,
                        &#39;previous&#39;: values.get(&#39;previous&#39;, &#39;&#39;),
                        &#39;drop&#39;: values.get(&#39;drop&#39;, &#39;&#39;)
                    })

            print(f&#34;CSV file &#39;{csv_filename}&#39; created successfully.&#34;)

       
    def add_minutes_to_time(self,input_time_str, delta_minutes):
        input_time = datetime.strptime(input_time_str, &#39;%H:%M:%S&#39;)
        result_time = input_time + timedelta(minutes=delta_minutes)
        result_time_str = result_time.strftime(&#39;%H:%M:%S&#39;)

        return result_time_str 

    def day_analyze_and_print_results(self, directory, time, seuil):
        day_data = Loader(directory).data_for_day(time)
        results_data = Calculation(directory).zscore_verification(day_data)
        
        abnormal = self.day_z_score_verification(results_data, seuil)
        following = self.day_following_timestamps(abnormal)
        previous_data = self.day_anomalie_slope(time, seuil)

        # Concatenate dictionaries with the desired format
        result_dict = self.following_error_drop_dict(following, previous_data)
        self.prettier_following_drop(result_dict)

    def day_mean_analyze_and_print_results(self, time, seuil):
        abnormal =self.day_mean_zscore_verification(time, seuil)
        following = self.day_following_timestamps(abnormal)
        previous_data = self.day_mean_anomalie_slope(time,seuil)
        result_dict = self.following_error_drop_dict(following, previous_data)
        self.prettier_following_drop(result_dict)
        
        
    def prettier_following_drop(self,result_dict):
        for key, data in result_dict.items():
            print(f&#34;\n{key} data:&#34;)
            print(&#34;{:&lt;12} {:&lt;10} {:&lt;10} {:&lt;10}&#34;.format(&#39;Time&#39;, &#39;End_time&#39; ,&#39;Previous&#39;, &#39;Drop&#39;))
            for time_key, values in data.items():
                print(&#34;{:&lt;12} {:&lt;10} {:&lt;10} {:&lt;10}&#34;.format(
                    time_key, self.add_minutes_to_time(time_key, values.get(&#39;previous&#39;, &#39;&#39;) ) , values.get(&#39;previous&#39;, &#39;&#39;), values.get(&#39;drop&#39;, &#39;&#39;)
                ))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="projet.verification.Verification.add_minutes_to_time"><code class="name flex">
<span>def <span class="ident">add_minutes_to_time</span></span>(<span>self, input_time_str, delta_minutes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_minutes_to_time(self,input_time_str, delta_minutes):
    input_time = datetime.strptime(input_time_str, &#39;%H:%M:%S&#39;)
    result_time = input_time + timedelta(minutes=delta_minutes)
    result_time_str = result_time.strftime(&#39;%H:%M:%S&#39;)

    return result_time_str </code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.convert_time_to_str"><code class="name flex">
<span>def <span class="ident">convert_time_to_str</span></span>(<span>self, time_obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_time_to_str(self,time_obj):
    return time_obj.strftime(&#39;%H:%M:%S&#39;)</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_analyze_and_print_results"><code class="name flex">
<span>def <span class="ident">day_analyze_and_print_results</span></span>(<span>self, directory, time, seuil)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_analyze_and_print_results(self, directory, time, seuil):
    day_data = Loader(directory).data_for_day(time)
    results_data = Calculation(directory).zscore_verification(day_data)
    
    abnormal = self.day_z_score_verification(results_data, seuil)
    following = self.day_following_timestamps(abnormal)
    previous_data = self.day_anomalie_slope(time, seuil)

    # Concatenate dictionaries with the desired format
    result_dict = self.following_error_drop_dict(following, previous_data)
    self.prettier_following_drop(result_dict)</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_anomalie_slope"><code class="name flex">
<span>def <span class="ident">day_anomalie_slope</span></span>(<span>self, date, seuil)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_anomalie_slope(self, date, seuil):
    z_columns_slopes = {}
    day_data = Loader(self.directory).data_for_day(date)
    zscore_calculation_data = Calculation(self.directory).zscore_verification(day_data)
    index_list = zscore_calculation_data.index.tolist()
    index_list.sort()
    errors = self.day_z_score_verification(zscore_calculation_data,seuil)
    anomalies = self.day_following_timestamps(errors)
    anomalie_slope = {}
    error_dict = {}
    for key, data_anomalie in anomalies.items():
        anomalie_dates = data_anomalie.keys()
        anomalie_dates = [time_index.strftime(&#39;%H:%M:%S&#39;) for time_index in anomalie_dates]
        for anomalie_date in anomalie_dates:  
            if isinstance(anomalie_date, str):
                anomalie_date = datetime.strptime(anomalie_date, &#39;%H:%M:%S&#39;).time() 
            current_index_position = index_list.index(anomalie_date)
            current_index = index_list[current_index_position]
            previous_index = index_list[current_index_position - 1] if current_index_position &gt; 0 else None
            assert previous_index != None, f&#39;There is no previous index for this data {index_list[current_index_position - 1]}&#39;
            drop = (day_data.loc[previous_index,remove_zscore_key_word(key)] - day_data.loc[current_index,remove_zscore_key_word(key)])  / day_data.loc[previous_index,remove_zscore_key_word(key)] * 100
          
            anomalie_slope[index_list[current_index_position]] = drop
        z_columns_slopes[key]= anomalie_slope
        anomalie_slope= {}
    return z_columns_slopes</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_following_timestamps"><code class="name flex">
<span>def <span class="ident">day_following_timestamps</span></span>(<span>self, timestamp_dict: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_following_timestamps(self,timestamp_dict: dict):

    all_first_anomalie_dict = {}
    for key, value in timestamp_dict.items():
        following_times = defaultdict(int)
        first_anomalie_dict = {}
        skip_list = set()
        first_main = []

        value = [datetime.strptime(item, &#39;%H:%M:%S&#39;) for item in value]
    

        for timestamp in value:
            delay = 0
            while (timestamp + timedelta(minutes=delay)) in value:
                delay +=  1

            
            following_times[timestamp.time()] = delay-1 #Subtract 1 beacause delay start at 0 so if an anomalie is detected but the the next value isn&#39;t an anomalie, delay == 1 but following_times should be 0
        results_dict = sorted(following_times.items())
        for index, row in results_dict:
            if index not in first_main:
                index_datetime = datetime.combine(datetime.min, index)
                if index_datetime not in skip_list:
                    first_main.append(index)
                    first_anomalie_dict[index] = row
                skip_list.update(datetime.combine(datetime.min, index) + timedelta(minutes=i) for i in range(1, row + 1))

        all_first_anomalie_dict[key] = first_anomalie_dict
        
    return all_first_anomalie_dict </code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_mean_analyze_and_print_results"><code class="name flex">
<span>def <span class="ident">day_mean_analyze_and_print_results</span></span>(<span>self, time, seuil)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_mean_analyze_and_print_results(self, time, seuil):
    abnormal =self.day_mean_zscore_verification(time, seuil)
    following = self.day_following_timestamps(abnormal)
    previous_data = self.day_mean_anomalie_slope(time,seuil)
    result_dict = self.following_error_drop_dict(following, previous_data)
    self.prettier_following_drop(result_dict)</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_mean_anomalie_slope"><code class="name flex">
<span>def <span class="ident">day_mean_anomalie_slope</span></span>(<span>self, date, seuil)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_mean_anomalie_slope(self, date, seuil):
    z_columns_slopes = {}
    results_data = Loader(self.directory).day_mean_result(date)
    index_list = results_data.index.tolist()
    index_list.sort()
    errors =self.day_mean_zscore_verification(date, seuil)
    anomalies = self.day_following_timestamps(errors)
    anomalie_slope = {}
    error_dict = {}
    for key, data_anomalie in anomalies.items():
        anomalie_dates = data_anomalie.keys()
        anomalie_dates = [time_index.strftime(&#39;%H:%M:%S&#39;) for time_index in anomalie_dates]
        
        for anomalie_date in anomalie_dates:
            current_index_position = index_list.index(anomalie_date)
            current_index = index_list[current_index_position]
            previous_index = index_list[current_index_position - 1] if current_index_position &gt; 0 else None

            if current_index_position == 0: 
                drop = 0
            else:
            #assert previous_index != None, &#39;There is no previous index for this data&#39;
                drop = (-results_data.loc[previous_index,remove_zscore_key_word(key)] + results_data.loc[current_index,remove_zscore_key_word(key)])  / results_data.loc[previous_index,remove_zscore_key_word(key)] * 100
            anomalie_slope[index_list[current_index_position]] = drop
            &#39;&#39;&#39;
            down_value = True
            
            index_delay = 0
            while down_value:
                
                index_delay +=1
                previous_index = index_list[current_index_position - index_delay] if current_index_position &gt; 0 else None
                if(previous_index == None):
                    down_value = False
                    break
                else:  
                    
                    current_index = index_list[current_index_position - (index_delay-1)]
                  

                    if results_data.loc[previous_index, key] &gt; results_data.loc[current_index, key]:
                        error_dict[current_index] = results_data.loc[current_index, remove_zscore_key_word(key)] - results_data.loc[previous_index, remove_zscore_key_word(key)]
                        
                    else:
                        down_value= False
                        anomalie_slope[index_list[current_index_position]] = error_dict
                      

        &#39;&#39;&#39;
        z_columns_slopes[key]= anomalie_slope
        anomalie_slope= {}
    return z_columns_slopes</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_mean_zscore_verification"><code class="name flex">
<span>def <span class="ident">day_mean_zscore_verification</span></span>(<span>self, date, seuil=3)</span>
</code></dt>
<dd>
<div class="desc"><p>For a selected date, verifies the result file associated and return all the dates with a zscore lesser than -2 and -3 on any of the columns. This method should be used after simple verification
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>date</code></strong> :&ensp;<code>dataframe.date</code></dt>
<dd>return 2 elemets : The first element is the list of all the data that has a zscore lower than 2 which corresponds to a medium level of anoamlie. The second element concerns all the data that has a zscore worst than -3 which corresponds to an anormal
data entry</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_mean_zscore_verification(self,date,seuil = 3):
    &#34;&#34;&#34;For a selected date, verifies the result file associated and return all the dates with a zscore lesser than -2 and -3 on any of the columns. This method should be used after simple verification  

    Args:
        date (dataframe.date): return 2 elemets : The first element is the list of all the data that has a zscore lower than 2 which corresponds to a medium level of anoamlie. The second element concerns all the data that has a zscore worst than -3 which corresponds to an anormal  data entry 
    &#34;&#34;&#34;
    
    results_data = Loader(self.directory).day_mean_result(date)
    zscore_columns = [&#39;z_score_revenue&#39;,
   &#39;z_score_auctions&#39;, &#39;z_score_impressions&#39;]

    anomalies = {}
    

    for column in zscore_columns:
        indices = results_data.index[results_data[column] &lt; -seuil].tolist()
        anomalies[column] =  list(set(indices))
        

    
    return anomalies</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_z_score_verification"><code class="name flex">
<span>def <span class="ident">day_z_score_verification</span></span>(<span>self, data: pandas.core.frame.DataFrame, seuil)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_z_score_verification(self, data: pd.DataFrame, seuil):
    zscore_columns = [&#39;z_score_revenue&#39;,
   &#39;z_score_auctions&#39;, &#39;z_score_impressions&#39;]

    anomalies = {}
 
    for column in zscore_columns:
        indices = data.index[data[column] &lt; -seuil].tolist()
        indices = [item.strftime(&#39;%H:%M:%S&#39;) for item in indices]
        anomalies[column] =  list(set(indices))


    return anomalies</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.following_error_drop_dict"><code class="name flex">
<span>def <span class="ident">following_error_drop_dict</span></span>(<span>self, following, previous_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def following_error_drop_dict(self,following,previous_data):
    result_dict = {}
    for key in following.keys():
        result_dict[key] = {}
        for time_key, value in following[key].items():
            str_time_key = self.convert_time_to_str(time_key)
            result_dict[key][str_time_key] = {&#39;previous&#39;: value}

        for time_key, value in previous_data[key].items():
            if isinstance(time_key, str) == False: 
                time_key = self.convert_time_to_str(time_key)
            str_time_key = time_key
            if str_time_key not in result_dict[key]:
                result_dict[key][str_time_key] = {}
            result_dict[key][str_time_key][&#39;drop&#39;] = value
    return result_dict</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.prettier_following_drop"><code class="name flex">
<span>def <span class="ident">prettier_following_drop</span></span>(<span>self, result_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prettier_following_drop(self,result_dict):
    for key, data in result_dict.items():
        print(f&#34;\n{key} data:&#34;)
        print(&#34;{:&lt;12} {:&lt;10} {:&lt;10} {:&lt;10}&#34;.format(&#39;Time&#39;, &#39;End_time&#39; ,&#39;Previous&#39;, &#39;Drop&#39;))
        for time_key, values in data.items():
            print(&#34;{:&lt;12} {:&lt;10} {:&lt;10} {:&lt;10}&#34;.format(
                time_key, self.add_minutes_to_time(time_key, values.get(&#39;previous&#39;, &#39;&#39;) ) , values.get(&#39;previous&#39;, &#39;&#39;), values.get(&#39;drop&#39;, &#39;&#39;)
            ))</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.save_following_drop_csv"><code class="name flex">
<span>def <span class="ident">save_following_drop_csv</span></span>(<span>result_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_following_drop_csv(result_dict):
     for key, data in result_dict.items():
        csv_filename = f&#34;{key}_data.csv&#34;
        with open(csv_filename, &#39;w&#39;, newline=&#39;&#39;) as csvfile:
            fieldnames = [&#39;time&#39;, &#39;previous&#39;, &#39;drop&#39;]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()

            for time_key, values in data.items():
                writer.writerow({
                    &#39;time&#39;: time_key,
                    &#39;previous&#39;: values.get(&#39;previous&#39;, &#39;&#39;),
                    &#39;drop&#39;: values.get(&#39;drop&#39;, &#39;&#39;)
                })

        print(f&#34;CSV file &#39;{csv_filename}&#39; created successfully.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="projet" href="index.html">projet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="projet.verification.remove_zscore_key_word" href="#projet.verification.remove_zscore_key_word">remove_zscore_key_word</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="projet.verification.Verification" href="#projet.verification.Verification">Verification</a></code></h4>
<ul class="">
<li><code><a title="projet.verification.Verification.add_minutes_to_time" href="#projet.verification.Verification.add_minutes_to_time">add_minutes_to_time</a></code></li>
<li><code><a title="projet.verification.Verification.convert_time_to_str" href="#projet.verification.Verification.convert_time_to_str">convert_time_to_str</a></code></li>
<li><code><a title="projet.verification.Verification.day_analyze_and_print_results" href="#projet.verification.Verification.day_analyze_and_print_results">day_analyze_and_print_results</a></code></li>
<li><code><a title="projet.verification.Verification.day_anomalie_slope" href="#projet.verification.Verification.day_anomalie_slope">day_anomalie_slope</a></code></li>
<li><code><a title="projet.verification.Verification.day_following_timestamps" href="#projet.verification.Verification.day_following_timestamps">day_following_timestamps</a></code></li>
<li><code><a title="projet.verification.Verification.day_mean_analyze_and_print_results" href="#projet.verification.Verification.day_mean_analyze_and_print_results">day_mean_analyze_and_print_results</a></code></li>
<li><code><a title="projet.verification.Verification.day_mean_anomalie_slope" href="#projet.verification.Verification.day_mean_anomalie_slope">day_mean_anomalie_slope</a></code></li>
<li><code><a title="projet.verification.Verification.day_mean_zscore_verification" href="#projet.verification.Verification.day_mean_zscore_verification">day_mean_zscore_verification</a></code></li>
<li><code><a title="projet.verification.Verification.day_z_score_verification" href="#projet.verification.Verification.day_z_score_verification">day_z_score_verification</a></code></li>
<li><code><a title="projet.verification.Verification.following_error_drop_dict" href="#projet.verification.Verification.following_error_drop_dict">following_error_drop_dict</a></code></li>
<li><code><a title="projet.verification.Verification.prettier_following_drop" href="#projet.verification.Verification.prettier_following_drop">prettier_following_drop</a></code></li>
<li><code><a title="projet.verification.Verification.save_following_drop_csv" href="#projet.verification.Verification.save_following_drop_csv">save_following_drop_csv</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>