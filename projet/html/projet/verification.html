<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>projet.verification API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>projet.verification</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import numpy as np 
import os
from datetime import datetime, timedelta
from collections import defaultdict
from tabulate import tabulate
import csv 
from loader import Loader
from calculation import Calculation

def remove_zscore_key_word(item :str):
            keyword = &#39;z_score_&#39;
            return item.replace(keyword,&#39;&#39;)

class Verification: 
    def __init__(self, directory) -&gt; None:
        &#34;&#34;&#34;Initialize the Verification class with the directory containing data files.

        Args:
            directory (str): The directory path containing the data files.

        Raises:
            ValueError: If the directory is None or invalid.
        &#34;&#34;&#34;
        self.directory = None 
        self.results_directory = None
        self.site_id = None
        assert directory is not None, &#34;Directory is none so we cannot affect the directory to the class&#34;
        directory = directory.strip()
        if os.path.dirname(directory) != &#34;data&#34;:
            directory = os.path.join(&#34;data&#34;, directory)
        if os.path.isdir(directory): 
            self.directory = directory
        else:
            raise ValueError (f&#34;The directory entered ({directory}) isn&#39;t a directory&#34;) 
        self.site_id = os.path.basename(directory)
        assert os.path.isdir(f&#39;{self.directory}/results&#39;), &#34;The selected directory doesn&#39;t have any results&#34;
        self.results_directory = f&#39;{self.directory}/results&#39;

    def day_mean_zscore_verification(self,date,seuil = 3):
        &#34;&#34;&#34;Verify the z-scores for a given date and return anomalies.

        Args:
            date (str): The date to be verified.
            seuil (int, optional): The threshold value for z-score anomalies. Defaults to 3.

        Returns:
            dict: A dictionary containing anomalies based on z-scores for each column.
        &#34;&#34;&#34;
        
        results_data = Loader(self.directory).day_mean_result(date)
        zscore_columns = [&#39;z_score_revenue&#39;,
       &#39;z_score_auctions&#39;, &#39;z_score_impressions&#39;]

        anomalies = {}
        

        for column in zscore_columns:
            indices = results_data.index[results_data[column] &lt; -seuil].tolist()
            anomalies[column] =  list(set(indices))
            

        
        return anomalies

    def day_z_score_verification(self, data: pd.DataFrame, seuil : float):
        &#34;&#34;&#34;Verify z-scores for a given DataFrame and return anomalies.

        Args:
            data (pd.DataFrame): The DataFrame to be verified.
            seuil (int): The threshold value for z-score anomalies.

        Returns:
            dict: A dictionary containing anomalies based on z-scores for each column.
        &#34;&#34;&#34;
        zscore_columns = [&#39;z_score_revenue&#39;,
       &#39;z_score_auctions&#39;, &#39;z_score_impressions&#39;]

        anomalies = {}
     
        for column in zscore_columns:
            indices = data.index[data[column] &lt; -seuil].tolist()
            indices = [item.strftime(&#39;%H:%M:%S&#39;) for item in indices]
            anomalies[column] =  list(set(indices))

    
        return anomalies
        
            

    def day_following_timestamps(self,timestamp_dict: dict):
        &#34;&#34;&#34;Find the following timestamps for anomalies.

        Args:
            timestamp_dict (dict): A dictionary containing timestamps of anomalies.

        Returns:
            dict: A dictionary containing the following timestamps for anomalies.
        &#34;&#34;&#34;

        all_first_anomalie_dict = {}
        for key, value in timestamp_dict.items():
            following_times = defaultdict(int)
            first_anomalie_dict = {}
            skip_list = set()
            first_main = []

            value = [datetime.strptime(item, &#39;%H:%M:%S&#39;) for item in value]
        

            for timestamp in value:
                delay = 0
                while (timestamp + timedelta(minutes=delay)) in value:
                    delay +=  1

                
                following_times[timestamp.time()] = delay-1 #Subtract 1 beacause delay start at 0 so if an anomalie is detected but the the next value isn&#39;t an anomalie, delay == 1 but following_times should be 0
            results_dict = sorted(following_times.items())
            for index, row in results_dict:
                if index not in first_main:
                    index_datetime = datetime.combine(datetime.min, index)
                    if index_datetime not in skip_list:
                        first_main.append(index)
                        first_anomalie_dict[index] = row
                    skip_list.update(datetime.combine(datetime.min, index) + timedelta(minutes=i) for i in range(1, row + 1))

            all_first_anomalie_dict[key] = first_anomalie_dict
            
        return all_first_anomalie_dict 


    def day_anomalie_slope(self, date : str, seuil : float):
        &#34;&#34;&#34;Calculate the slope of anomalies for a given date.

        Args:
            date (str): The date to be analyzed.
            seuil (int): The threshold value for z-score anomalies.

        Returns:
            dict: A dictionary containing the slope of anomalies for each column.
        &#34;&#34;&#34;
        z_columns_slopes = {}
        day_data = Loader(self.directory).data_for_day(date)
        zscore_calculation_data = Calculation(self.directory).zscore_verification(day_data)
        index_list = zscore_calculation_data.index.tolist()
        index_list.sort()
        errors = self.day_z_score_verification(zscore_calculation_data,seuil)
        anomalies = self.day_following_timestamps(errors)
        anomalie_slope = {}
        error_dict = {}
        for key, data_anomalie in anomalies.items():
            anomalie_dates = data_anomalie.keys()
            anomalie_dates = [time_index.strftime(&#39;%H:%M:%S&#39;) for time_index in anomalie_dates]
            for anomalie_date in anomalie_dates:  
                if isinstance(anomalie_date, str):
                    anomalie_date = datetime.strptime(anomalie_date, &#39;%H:%M:%S&#39;).time() 
                current_index_position = index_list.index(anomalie_date)
                current_index = index_list[current_index_position]
                previous_index = index_list[current_index_position - 1] if current_index_position &gt; 0 else None
                assert previous_index != None, f&#39;There is no previous index for this data {index_list[current_index_position - 1]}&#39;
                drop = (day_data.loc[previous_index,remove_zscore_key_word(key)] - day_data.loc[current_index,remove_zscore_key_word(key)])  / day_data.loc[previous_index,remove_zscore_key_word(key)] * 100
              
                anomalie_slope[index_list[current_index_position]] = drop
            z_columns_slopes[key]= anomalie_slope
            anomalie_slope= {}
        return z_columns_slopes
        

        
    def day_mean_anomalie_slope(self, date : str, seuil : float):
        &#34;&#34;&#34;Calculate the mean slope of anomalies for a given date.

        Args:
            date (str): The date to be analyzed.
            seuil (int): The threshold value for z-score anomalies.

        Returns:
            dict: A dictionary containing the mean slope of anomalies for each column.
        &#34;&#34;&#34;
        z_columns_slopes = {}
        results_data = Loader(self.directory).day_mean_result(date)
        index_list = results_data.index.tolist()
        index_list.sort()
        errors =self.day_mean_zscore_verification(date, seuil)
        anomalies = self.day_following_timestamps(errors)
        anomalie_slope = {}
        error_dict = {}
        for key, data_anomalie in anomalies.items():
            anomalie_dates = data_anomalie.keys()
            anomalie_dates = [time_index.strftime(&#39;%H:%M:%S&#39;) for time_index in anomalie_dates]
            
            for anomalie_date in anomalie_dates:
                current_index_position = index_list.index(anomalie_date)
                current_index = index_list[current_index_position]
                previous_index = index_list[current_index_position - 1] if current_index_position &gt; 0 else None

                if current_index_position == 0: 
                    drop = 0
                else:
                #assert previous_index != None, &#39;There is no previous index for this data&#39;
                    drop = (-results_data.loc[previous_index,remove_zscore_key_word(key)] + results_data.loc[current_index,remove_zscore_key_word(key)])  / results_data.loc[previous_index,remove_zscore_key_word(key)] * 100
                anomalie_slope[index_list[current_index_position]] = drop
           
            z_columns_slopes[key]= anomalie_slope
            anomalie_slope= {}
        return z_columns_slopes
        
            
    def convert_time_to_str(self,time_obj : datetime.time):
        &#34;&#34;&#34;Convert a datetime object to a string in &#39;%H:%M:%S&#39; format.

        Args:
            time_obj (datetime): The datetime object to be converted.

        Returns:
            str: The string representation of the time object.
        &#34;&#34;&#34;
        return time_obj.strftime(&#39;%H:%M:%S&#39;)

    def following_error_drop_dict(self,following : dict,previous_data: dict):
        &#34;&#34;&#34;Combine following anomalies with their corresponding drop values.

        Args:
            following (dict): A dictionary containing following anomalies.
            previous_data (dict): A dictionary containing previous data.

        Returns:
            dict: A dictionary containing following anomalies with drop values.
        &#34;&#34;&#34;
        result_dict = {}
        for key in following.keys():
            result_dict[key] = {}
            for time_key, value in following[key].items():
                str_time_key = self.convert_time_to_str(time_key)
                result_dict[key][str_time_key] = {&#39;previous&#39;: value}

            for time_key, value in previous_data[key].items():
                if isinstance(time_key, str) == False: 
                    time_key = self.convert_time_to_str(time_key)
                str_time_key = time_key
                if str_time_key not in result_dict[key]:
                    result_dict[key][str_time_key] = {}
                result_dict[key][str_time_key][&#39;drop&#39;] = value
        return result_dict
        
    def save_following_drop_csv(result_dict: dict):
        &#34;&#34;&#34;Save following anomalies with drop values to a CSV file.

        Args:
            result_dict (dict): A dictionary containing following anomalies with drop values.
        &#34;&#34;&#34;
        for key, data in result_dict.items():
            csv_filename = f&#34;{key}_data.csv&#34;
            with open(csv_filename, &#39;w&#39;, newline=&#39;&#39;) as csvfile:
                fieldnames = [&#39;time&#39;, &#39;previous&#39;, &#39;drop&#39;]
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()

                for time_key, values in data.items():
                    writer.writerow({
                        &#39;time&#39;: time_key,
                        &#39;previous&#39;: values.get(&#39;previous&#39;, &#39;&#39;),
                        &#39;drop&#39;: values.get(&#39;drop&#39;, &#39;&#39;)
                    })

            print(f&#34;CSV file &#39;{csv_filename}&#39; created successfully.&#34;)

       
    def add_minutes_to_time(self,input_time_str:str, delta_minutes : int):
        &#34;&#34;&#34;Add minutes to a time string.

        Args:
            input_time_str (str): The input time string in &#39;%H:%M:%S&#39; format.
            delta_minutes (int): The number of minutes to add.

        Returns:
            str: The resulting time string after adding minutes.
        &#34;&#34;&#34;
        input_time = datetime.strptime(input_time_str, &#39;%H:%M:%S&#39;)
        result_time = input_time + timedelta(minutes=delta_minutes)
        result_time_str = result_time.strftime(&#39;%H:%M:%S&#39;)

        return result_time_str 

    def day_analyze_and_print_results(self, directory:str, time:str, seuil:float):
        &#34;&#34;&#34;Analyze anomalies for a given day and print the results.

        Args:
            directory (str): The directory containing data files.
            time (str): The date to be analyzed.
            seuil (int): The threshold value for z-score anomalies.

        Returns:
            None
        &#34;&#34;&#34;
        day_data = Loader(directory).data_for_day(time)
        results_data = Calculation(directory).zscore_verification(day_data)
        
        abnormal = self.day_z_score_verification(results_data, seuil)
        following = self.day_following_timestamps(abnormal)
        previous_data = self.day_anomalie_slope(time, seuil)

        # Concatenate dictionaries with the desired format
        result_dict = self.following_error_drop_dict(following, previous_data)
        self.prettier_following_drop(result_dict)

    def day_mean_analyze_and_print_results(self, time : str, seuil : float):
        &#34;&#34;&#34;Analyze mean anomalies for a given day and print the results.

        Args:
            time (str): The date to be analyzed.
            seuil (int): The threshold value for z-score anomalies.

        Returns:
            None
        &#34;&#34;&#34;
        abnormal =self.day_mean_zscore_verification(time, seuil)
        following = self.day_following_timestamps(abnormal)
        previous_data = self.day_mean_anomalie_slope(time,seuil)
        result_dict = self.following_error_drop_dict(following, previous_data)
        self.prettier_following_drop(result_dict)
        
        
    def prettier_following_drop(self,result_dict):
        &#34;&#34;&#34;Print following anomalies with drop values in a prettier format.

        Args:
            result_dict (dict): A dictionary containing following anomalies with drop values.

        Returns:
            None
        &#34;&#34;&#34;
        for key, data in result_dict.items():
            print(f&#34;\n{key} data:&#34;)
            print(&#34;{:&lt;12} {:&lt;10} {:&lt;10} {:&lt;10}&#34;.format(&#39;Time&#39;, &#39;End_time&#39; ,&#39;Previous&#39;, &#39;Drop&#39;))
            for time_key, values in data.items():
                print(&#34;{:&lt;12} {:&lt;10} {:&lt;10} {:&lt;10}&#34;.format(
                    time_key, self.add_minutes_to_time(time_key, values.get(&#39;previous&#39;, &#39;&#39;) ) , values.get(&#39;previous&#39;, &#39;&#39;), values.get(&#39;drop&#39;, &#39;&#39;)
                ))


               
if __name__ == &#34;__main__&#34;:
    directory = &#39;data/3ee1bd1f-01d8-4277-929d-53b1cebe457b&#39;
    time = &#34;2023-09-29&#34;
    ver = Verification(directory)
    seuil = 2
    
    mean =False 
    if mean: 
        ver.day_mean_analyze_and_print_results(time,seuil)
    else:    
        ver.day_analyze_and_print_results(directory,time,seuil)
    
   
    
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="projet.verification.remove_zscore_key_word"><code class="name flex">
<span>def <span class="ident">remove_zscore_key_word</span></span>(<span>item: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_zscore_key_word(item :str):
            keyword = &#39;z_score_&#39;
            return item.replace(keyword,&#39;&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="projet.verification.Verification"><code class="flex name class">
<span>class <span class="ident">Verification</span></span>
<span>(</span><span>directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the Verification class with the directory containing data files.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>The directory path containing the data files.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the directory is None or invalid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Verification: 
    def __init__(self, directory) -&gt; None:
        &#34;&#34;&#34;Initialize the Verification class with the directory containing data files.

        Args:
            directory (str): The directory path containing the data files.

        Raises:
            ValueError: If the directory is None or invalid.
        &#34;&#34;&#34;
        self.directory = None 
        self.results_directory = None
        self.site_id = None
        assert directory is not None, &#34;Directory is none so we cannot affect the directory to the class&#34;
        directory = directory.strip()
        if os.path.dirname(directory) != &#34;data&#34;:
            directory = os.path.join(&#34;data&#34;, directory)
        if os.path.isdir(directory): 
            self.directory = directory
        else:
            raise ValueError (f&#34;The directory entered ({directory}) isn&#39;t a directory&#34;) 
        self.site_id = os.path.basename(directory)
        assert os.path.isdir(f&#39;{self.directory}/results&#39;), &#34;The selected directory doesn&#39;t have any results&#34;
        self.results_directory = f&#39;{self.directory}/results&#39;

    def day_mean_zscore_verification(self,date,seuil = 3):
        &#34;&#34;&#34;Verify the z-scores for a given date and return anomalies.

        Args:
            date (str): The date to be verified.
            seuil (int, optional): The threshold value for z-score anomalies. Defaults to 3.

        Returns:
            dict: A dictionary containing anomalies based on z-scores for each column.
        &#34;&#34;&#34;
        
        results_data = Loader(self.directory).day_mean_result(date)
        zscore_columns = [&#39;z_score_revenue&#39;,
       &#39;z_score_auctions&#39;, &#39;z_score_impressions&#39;]

        anomalies = {}
        

        for column in zscore_columns:
            indices = results_data.index[results_data[column] &lt; -seuil].tolist()
            anomalies[column] =  list(set(indices))
            

        
        return anomalies

    def day_z_score_verification(self, data: pd.DataFrame, seuil : float):
        &#34;&#34;&#34;Verify z-scores for a given DataFrame and return anomalies.

        Args:
            data (pd.DataFrame): The DataFrame to be verified.
            seuil (int): The threshold value for z-score anomalies.

        Returns:
            dict: A dictionary containing anomalies based on z-scores for each column.
        &#34;&#34;&#34;
        zscore_columns = [&#39;z_score_revenue&#39;,
       &#39;z_score_auctions&#39;, &#39;z_score_impressions&#39;]

        anomalies = {}
     
        for column in zscore_columns:
            indices = data.index[data[column] &lt; -seuil].tolist()
            indices = [item.strftime(&#39;%H:%M:%S&#39;) for item in indices]
            anomalies[column] =  list(set(indices))

    
        return anomalies
        
            

    def day_following_timestamps(self,timestamp_dict: dict):
        &#34;&#34;&#34;Find the following timestamps for anomalies.

        Args:
            timestamp_dict (dict): A dictionary containing timestamps of anomalies.

        Returns:
            dict: A dictionary containing the following timestamps for anomalies.
        &#34;&#34;&#34;

        all_first_anomalie_dict = {}
        for key, value in timestamp_dict.items():
            following_times = defaultdict(int)
            first_anomalie_dict = {}
            skip_list = set()
            first_main = []

            value = [datetime.strptime(item, &#39;%H:%M:%S&#39;) for item in value]
        

            for timestamp in value:
                delay = 0
                while (timestamp + timedelta(minutes=delay)) in value:
                    delay +=  1

                
                following_times[timestamp.time()] = delay-1 #Subtract 1 beacause delay start at 0 so if an anomalie is detected but the the next value isn&#39;t an anomalie, delay == 1 but following_times should be 0
            results_dict = sorted(following_times.items())
            for index, row in results_dict:
                if index not in first_main:
                    index_datetime = datetime.combine(datetime.min, index)
                    if index_datetime not in skip_list:
                        first_main.append(index)
                        first_anomalie_dict[index] = row
                    skip_list.update(datetime.combine(datetime.min, index) + timedelta(minutes=i) for i in range(1, row + 1))

            all_first_anomalie_dict[key] = first_anomalie_dict
            
        return all_first_anomalie_dict 


    def day_anomalie_slope(self, date : str, seuil : float):
        &#34;&#34;&#34;Calculate the slope of anomalies for a given date.

        Args:
            date (str): The date to be analyzed.
            seuil (int): The threshold value for z-score anomalies.

        Returns:
            dict: A dictionary containing the slope of anomalies for each column.
        &#34;&#34;&#34;
        z_columns_slopes = {}
        day_data = Loader(self.directory).data_for_day(date)
        zscore_calculation_data = Calculation(self.directory).zscore_verification(day_data)
        index_list = zscore_calculation_data.index.tolist()
        index_list.sort()
        errors = self.day_z_score_verification(zscore_calculation_data,seuil)
        anomalies = self.day_following_timestamps(errors)
        anomalie_slope = {}
        error_dict = {}
        for key, data_anomalie in anomalies.items():
            anomalie_dates = data_anomalie.keys()
            anomalie_dates = [time_index.strftime(&#39;%H:%M:%S&#39;) for time_index in anomalie_dates]
            for anomalie_date in anomalie_dates:  
                if isinstance(anomalie_date, str):
                    anomalie_date = datetime.strptime(anomalie_date, &#39;%H:%M:%S&#39;).time() 
                current_index_position = index_list.index(anomalie_date)
                current_index = index_list[current_index_position]
                previous_index = index_list[current_index_position - 1] if current_index_position &gt; 0 else None
                assert previous_index != None, f&#39;There is no previous index for this data {index_list[current_index_position - 1]}&#39;
                drop = (day_data.loc[previous_index,remove_zscore_key_word(key)] - day_data.loc[current_index,remove_zscore_key_word(key)])  / day_data.loc[previous_index,remove_zscore_key_word(key)] * 100
              
                anomalie_slope[index_list[current_index_position]] = drop
            z_columns_slopes[key]= anomalie_slope
            anomalie_slope= {}
        return z_columns_slopes
        

        
    def day_mean_anomalie_slope(self, date : str, seuil : float):
        &#34;&#34;&#34;Calculate the mean slope of anomalies for a given date.

        Args:
            date (str): The date to be analyzed.
            seuil (int): The threshold value for z-score anomalies.

        Returns:
            dict: A dictionary containing the mean slope of anomalies for each column.
        &#34;&#34;&#34;
        z_columns_slopes = {}
        results_data = Loader(self.directory).day_mean_result(date)
        index_list = results_data.index.tolist()
        index_list.sort()
        errors =self.day_mean_zscore_verification(date, seuil)
        anomalies = self.day_following_timestamps(errors)
        anomalie_slope = {}
        error_dict = {}
        for key, data_anomalie in anomalies.items():
            anomalie_dates = data_anomalie.keys()
            anomalie_dates = [time_index.strftime(&#39;%H:%M:%S&#39;) for time_index in anomalie_dates]
            
            for anomalie_date in anomalie_dates:
                current_index_position = index_list.index(anomalie_date)
                current_index = index_list[current_index_position]
                previous_index = index_list[current_index_position - 1] if current_index_position &gt; 0 else None

                if current_index_position == 0: 
                    drop = 0
                else:
                #assert previous_index != None, &#39;There is no previous index for this data&#39;
                    drop = (-results_data.loc[previous_index,remove_zscore_key_word(key)] + results_data.loc[current_index,remove_zscore_key_word(key)])  / results_data.loc[previous_index,remove_zscore_key_word(key)] * 100
                anomalie_slope[index_list[current_index_position]] = drop
           
            z_columns_slopes[key]= anomalie_slope
            anomalie_slope= {}
        return z_columns_slopes
        
            
    def convert_time_to_str(self,time_obj : datetime.time):
        &#34;&#34;&#34;Convert a datetime object to a string in &#39;%H:%M:%S&#39; format.

        Args:
            time_obj (datetime): The datetime object to be converted.

        Returns:
            str: The string representation of the time object.
        &#34;&#34;&#34;
        return time_obj.strftime(&#39;%H:%M:%S&#39;)

    def following_error_drop_dict(self,following : dict,previous_data: dict):
        &#34;&#34;&#34;Combine following anomalies with their corresponding drop values.

        Args:
            following (dict): A dictionary containing following anomalies.
            previous_data (dict): A dictionary containing previous data.

        Returns:
            dict: A dictionary containing following anomalies with drop values.
        &#34;&#34;&#34;
        result_dict = {}
        for key in following.keys():
            result_dict[key] = {}
            for time_key, value in following[key].items():
                str_time_key = self.convert_time_to_str(time_key)
                result_dict[key][str_time_key] = {&#39;previous&#39;: value}

            for time_key, value in previous_data[key].items():
                if isinstance(time_key, str) == False: 
                    time_key = self.convert_time_to_str(time_key)
                str_time_key = time_key
                if str_time_key not in result_dict[key]:
                    result_dict[key][str_time_key] = {}
                result_dict[key][str_time_key][&#39;drop&#39;] = value
        return result_dict
        
    def save_following_drop_csv(result_dict: dict):
        &#34;&#34;&#34;Save following anomalies with drop values to a CSV file.

        Args:
            result_dict (dict): A dictionary containing following anomalies with drop values.
        &#34;&#34;&#34;
        for key, data in result_dict.items():
            csv_filename = f&#34;{key}_data.csv&#34;
            with open(csv_filename, &#39;w&#39;, newline=&#39;&#39;) as csvfile:
                fieldnames = [&#39;time&#39;, &#39;previous&#39;, &#39;drop&#39;]
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()

                for time_key, values in data.items():
                    writer.writerow({
                        &#39;time&#39;: time_key,
                        &#39;previous&#39;: values.get(&#39;previous&#39;, &#39;&#39;),
                        &#39;drop&#39;: values.get(&#39;drop&#39;, &#39;&#39;)
                    })

            print(f&#34;CSV file &#39;{csv_filename}&#39; created successfully.&#34;)

       
    def add_minutes_to_time(self,input_time_str:str, delta_minutes : int):
        &#34;&#34;&#34;Add minutes to a time string.

        Args:
            input_time_str (str): The input time string in &#39;%H:%M:%S&#39; format.
            delta_minutes (int): The number of minutes to add.

        Returns:
            str: The resulting time string after adding minutes.
        &#34;&#34;&#34;
        input_time = datetime.strptime(input_time_str, &#39;%H:%M:%S&#39;)
        result_time = input_time + timedelta(minutes=delta_minutes)
        result_time_str = result_time.strftime(&#39;%H:%M:%S&#39;)

        return result_time_str 

    def day_analyze_and_print_results(self, directory:str, time:str, seuil:float):
        &#34;&#34;&#34;Analyze anomalies for a given day and print the results.

        Args:
            directory (str): The directory containing data files.
            time (str): The date to be analyzed.
            seuil (int): The threshold value for z-score anomalies.

        Returns:
            None
        &#34;&#34;&#34;
        day_data = Loader(directory).data_for_day(time)
        results_data = Calculation(directory).zscore_verification(day_data)
        
        abnormal = self.day_z_score_verification(results_data, seuil)
        following = self.day_following_timestamps(abnormal)
        previous_data = self.day_anomalie_slope(time, seuil)

        # Concatenate dictionaries with the desired format
        result_dict = self.following_error_drop_dict(following, previous_data)
        self.prettier_following_drop(result_dict)

    def day_mean_analyze_and_print_results(self, time : str, seuil : float):
        &#34;&#34;&#34;Analyze mean anomalies for a given day and print the results.

        Args:
            time (str): The date to be analyzed.
            seuil (int): The threshold value for z-score anomalies.

        Returns:
            None
        &#34;&#34;&#34;
        abnormal =self.day_mean_zscore_verification(time, seuil)
        following = self.day_following_timestamps(abnormal)
        previous_data = self.day_mean_anomalie_slope(time,seuil)
        result_dict = self.following_error_drop_dict(following, previous_data)
        self.prettier_following_drop(result_dict)
        
        
    def prettier_following_drop(self,result_dict):
        &#34;&#34;&#34;Print following anomalies with drop values in a prettier format.

        Args:
            result_dict (dict): A dictionary containing following anomalies with drop values.

        Returns:
            None
        &#34;&#34;&#34;
        for key, data in result_dict.items():
            print(f&#34;\n{key} data:&#34;)
            print(&#34;{:&lt;12} {:&lt;10} {:&lt;10} {:&lt;10}&#34;.format(&#39;Time&#39;, &#39;End_time&#39; ,&#39;Previous&#39;, &#39;Drop&#39;))
            for time_key, values in data.items():
                print(&#34;{:&lt;12} {:&lt;10} {:&lt;10} {:&lt;10}&#34;.format(
                    time_key, self.add_minutes_to_time(time_key, values.get(&#39;previous&#39;, &#39;&#39;) ) , values.get(&#39;previous&#39;, &#39;&#39;), values.get(&#39;drop&#39;, &#39;&#39;)
                ))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="projet.verification.Verification.add_minutes_to_time"><code class="name flex">
<span>def <span class="ident">add_minutes_to_time</span></span>(<span>self, input_time_str: str, delta_minutes: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Add minutes to a time string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_time_str</code></strong> :&ensp;<code>str</code></dt>
<dd>The input time string in '%H:%M:%S' format.</dd>
<dt><strong><code>delta_minutes</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of minutes to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The resulting time string after adding minutes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_minutes_to_time(self,input_time_str:str, delta_minutes : int):
    &#34;&#34;&#34;Add minutes to a time string.

    Args:
        input_time_str (str): The input time string in &#39;%H:%M:%S&#39; format.
        delta_minutes (int): The number of minutes to add.

    Returns:
        str: The resulting time string after adding minutes.
    &#34;&#34;&#34;
    input_time = datetime.strptime(input_time_str, &#39;%H:%M:%S&#39;)
    result_time = input_time + timedelta(minutes=delta_minutes)
    result_time_str = result_time.strftime(&#39;%H:%M:%S&#39;)

    return result_time_str </code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.convert_time_to_str"><code class="name flex">
<span>def <span class="ident">convert_time_to_str</span></span>(<span>self, time_obj: <method 'time' of 'datetime.datetime' objects>)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a datetime object to a string in '%H:%M:%S' format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>time_obj</code></strong> :&ensp;<code>datetime</code></dt>
<dd>The datetime object to be converted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The string representation of the time object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_time_to_str(self,time_obj : datetime.time):
    &#34;&#34;&#34;Convert a datetime object to a string in &#39;%H:%M:%S&#39; format.

    Args:
        time_obj (datetime): The datetime object to be converted.

    Returns:
        str: The string representation of the time object.
    &#34;&#34;&#34;
    return time_obj.strftime(&#39;%H:%M:%S&#39;)</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_analyze_and_print_results"><code class="name flex">
<span>def <span class="ident">day_analyze_and_print_results</span></span>(<span>self, directory: str, time: str, seuil: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Analyze anomalies for a given day and print the results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>The directory containing data files.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>str</code></dt>
<dd>The date to be analyzed.</dd>
<dt><strong><code>seuil</code></strong> :&ensp;<code>int</code></dt>
<dd>The threshold value for z-score anomalies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_analyze_and_print_results(self, directory:str, time:str, seuil:float):
    &#34;&#34;&#34;Analyze anomalies for a given day and print the results.

    Args:
        directory (str): The directory containing data files.
        time (str): The date to be analyzed.
        seuil (int): The threshold value for z-score anomalies.

    Returns:
        None
    &#34;&#34;&#34;
    day_data = Loader(directory).data_for_day(time)
    results_data = Calculation(directory).zscore_verification(day_data)
    
    abnormal = self.day_z_score_verification(results_data, seuil)
    following = self.day_following_timestamps(abnormal)
    previous_data = self.day_anomalie_slope(time, seuil)

    # Concatenate dictionaries with the desired format
    result_dict = self.following_error_drop_dict(following, previous_data)
    self.prettier_following_drop(result_dict)</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_anomalie_slope"><code class="name flex">
<span>def <span class="ident">day_anomalie_slope</span></span>(<span>self, date: str, seuil: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the slope of anomalies for a given date.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>date</code></strong> :&ensp;<code>str</code></dt>
<dd>The date to be analyzed.</dd>
<dt><strong><code>seuil</code></strong> :&ensp;<code>int</code></dt>
<dd>The threshold value for z-score anomalies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the slope of anomalies for each column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_anomalie_slope(self, date : str, seuil : float):
    &#34;&#34;&#34;Calculate the slope of anomalies for a given date.

    Args:
        date (str): The date to be analyzed.
        seuil (int): The threshold value for z-score anomalies.

    Returns:
        dict: A dictionary containing the slope of anomalies for each column.
    &#34;&#34;&#34;
    z_columns_slopes = {}
    day_data = Loader(self.directory).data_for_day(date)
    zscore_calculation_data = Calculation(self.directory).zscore_verification(day_data)
    index_list = zscore_calculation_data.index.tolist()
    index_list.sort()
    errors = self.day_z_score_verification(zscore_calculation_data,seuil)
    anomalies = self.day_following_timestamps(errors)
    anomalie_slope = {}
    error_dict = {}
    for key, data_anomalie in anomalies.items():
        anomalie_dates = data_anomalie.keys()
        anomalie_dates = [time_index.strftime(&#39;%H:%M:%S&#39;) for time_index in anomalie_dates]
        for anomalie_date in anomalie_dates:  
            if isinstance(anomalie_date, str):
                anomalie_date = datetime.strptime(anomalie_date, &#39;%H:%M:%S&#39;).time() 
            current_index_position = index_list.index(anomalie_date)
            current_index = index_list[current_index_position]
            previous_index = index_list[current_index_position - 1] if current_index_position &gt; 0 else None
            assert previous_index != None, f&#39;There is no previous index for this data {index_list[current_index_position - 1]}&#39;
            drop = (day_data.loc[previous_index,remove_zscore_key_word(key)] - day_data.loc[current_index,remove_zscore_key_word(key)])  / day_data.loc[previous_index,remove_zscore_key_word(key)] * 100
          
            anomalie_slope[index_list[current_index_position]] = drop
        z_columns_slopes[key]= anomalie_slope
        anomalie_slope= {}
    return z_columns_slopes</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_following_timestamps"><code class="name flex">
<span>def <span class="ident">day_following_timestamps</span></span>(<span>self, timestamp_dict: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the following timestamps for anomalies.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timestamp_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing timestamps of anomalies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the following timestamps for anomalies.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_following_timestamps(self,timestamp_dict: dict):
    &#34;&#34;&#34;Find the following timestamps for anomalies.

    Args:
        timestamp_dict (dict): A dictionary containing timestamps of anomalies.

    Returns:
        dict: A dictionary containing the following timestamps for anomalies.
    &#34;&#34;&#34;

    all_first_anomalie_dict = {}
    for key, value in timestamp_dict.items():
        following_times = defaultdict(int)
        first_anomalie_dict = {}
        skip_list = set()
        first_main = []

        value = [datetime.strptime(item, &#39;%H:%M:%S&#39;) for item in value]
    

        for timestamp in value:
            delay = 0
            while (timestamp + timedelta(minutes=delay)) in value:
                delay +=  1

            
            following_times[timestamp.time()] = delay-1 #Subtract 1 beacause delay start at 0 so if an anomalie is detected but the the next value isn&#39;t an anomalie, delay == 1 but following_times should be 0
        results_dict = sorted(following_times.items())
        for index, row in results_dict:
            if index not in first_main:
                index_datetime = datetime.combine(datetime.min, index)
                if index_datetime not in skip_list:
                    first_main.append(index)
                    first_anomalie_dict[index] = row
                skip_list.update(datetime.combine(datetime.min, index) + timedelta(minutes=i) for i in range(1, row + 1))

        all_first_anomalie_dict[key] = first_anomalie_dict
        
    return all_first_anomalie_dict </code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_mean_analyze_and_print_results"><code class="name flex">
<span>def <span class="ident">day_mean_analyze_and_print_results</span></span>(<span>self, time: str, seuil: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Analyze mean anomalies for a given day and print the results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>str</code></dt>
<dd>The date to be analyzed.</dd>
<dt><strong><code>seuil</code></strong> :&ensp;<code>int</code></dt>
<dd>The threshold value for z-score anomalies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_mean_analyze_and_print_results(self, time : str, seuil : float):
    &#34;&#34;&#34;Analyze mean anomalies for a given day and print the results.

    Args:
        time (str): The date to be analyzed.
        seuil (int): The threshold value for z-score anomalies.

    Returns:
        None
    &#34;&#34;&#34;
    abnormal =self.day_mean_zscore_verification(time, seuil)
    following = self.day_following_timestamps(abnormal)
    previous_data = self.day_mean_anomalie_slope(time,seuil)
    result_dict = self.following_error_drop_dict(following, previous_data)
    self.prettier_following_drop(result_dict)</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_mean_anomalie_slope"><code class="name flex">
<span>def <span class="ident">day_mean_anomalie_slope</span></span>(<span>self, date: str, seuil: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the mean slope of anomalies for a given date.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>date</code></strong> :&ensp;<code>str</code></dt>
<dd>The date to be analyzed.</dd>
<dt><strong><code>seuil</code></strong> :&ensp;<code>int</code></dt>
<dd>The threshold value for z-score anomalies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the mean slope of anomalies for each column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_mean_anomalie_slope(self, date : str, seuil : float):
    &#34;&#34;&#34;Calculate the mean slope of anomalies for a given date.

    Args:
        date (str): The date to be analyzed.
        seuil (int): The threshold value for z-score anomalies.

    Returns:
        dict: A dictionary containing the mean slope of anomalies for each column.
    &#34;&#34;&#34;
    z_columns_slopes = {}
    results_data = Loader(self.directory).day_mean_result(date)
    index_list = results_data.index.tolist()
    index_list.sort()
    errors =self.day_mean_zscore_verification(date, seuil)
    anomalies = self.day_following_timestamps(errors)
    anomalie_slope = {}
    error_dict = {}
    for key, data_anomalie in anomalies.items():
        anomalie_dates = data_anomalie.keys()
        anomalie_dates = [time_index.strftime(&#39;%H:%M:%S&#39;) for time_index in anomalie_dates]
        
        for anomalie_date in anomalie_dates:
            current_index_position = index_list.index(anomalie_date)
            current_index = index_list[current_index_position]
            previous_index = index_list[current_index_position - 1] if current_index_position &gt; 0 else None

            if current_index_position == 0: 
                drop = 0
            else:
            #assert previous_index != None, &#39;There is no previous index for this data&#39;
                drop = (-results_data.loc[previous_index,remove_zscore_key_word(key)] + results_data.loc[current_index,remove_zscore_key_word(key)])  / results_data.loc[previous_index,remove_zscore_key_word(key)] * 100
            anomalie_slope[index_list[current_index_position]] = drop
       
        z_columns_slopes[key]= anomalie_slope
        anomalie_slope= {}
    return z_columns_slopes</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_mean_zscore_verification"><code class="name flex">
<span>def <span class="ident">day_mean_zscore_verification</span></span>(<span>self, date, seuil=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify the z-scores for a given date and return anomalies.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>date</code></strong> :&ensp;<code>str</code></dt>
<dd>The date to be verified.</dd>
<dt><strong><code>seuil</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The threshold value for z-score anomalies. Defaults to 3.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing anomalies based on z-scores for each column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_mean_zscore_verification(self,date,seuil = 3):
    &#34;&#34;&#34;Verify the z-scores for a given date and return anomalies.

    Args:
        date (str): The date to be verified.
        seuil (int, optional): The threshold value for z-score anomalies. Defaults to 3.

    Returns:
        dict: A dictionary containing anomalies based on z-scores for each column.
    &#34;&#34;&#34;
    
    results_data = Loader(self.directory).day_mean_result(date)
    zscore_columns = [&#39;z_score_revenue&#39;,
   &#39;z_score_auctions&#39;, &#39;z_score_impressions&#39;]

    anomalies = {}
    

    for column in zscore_columns:
        indices = results_data.index[results_data[column] &lt; -seuil].tolist()
        anomalies[column] =  list(set(indices))
        

    
    return anomalies</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.day_z_score_verification"><code class="name flex">
<span>def <span class="ident">day_z_score_verification</span></span>(<span>self, data: pandas.core.frame.DataFrame, seuil: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify z-scores for a given DataFrame and return anomalies.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The DataFrame to be verified.</dd>
<dt><strong><code>seuil</code></strong> :&ensp;<code>int</code></dt>
<dd>The threshold value for z-score anomalies.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing anomalies based on z-scores for each column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def day_z_score_verification(self, data: pd.DataFrame, seuil : float):
    &#34;&#34;&#34;Verify z-scores for a given DataFrame and return anomalies.

    Args:
        data (pd.DataFrame): The DataFrame to be verified.
        seuil (int): The threshold value for z-score anomalies.

    Returns:
        dict: A dictionary containing anomalies based on z-scores for each column.
    &#34;&#34;&#34;
    zscore_columns = [&#39;z_score_revenue&#39;,
   &#39;z_score_auctions&#39;, &#39;z_score_impressions&#39;]

    anomalies = {}
 
    for column in zscore_columns:
        indices = data.index[data[column] &lt; -seuil].tolist()
        indices = [item.strftime(&#39;%H:%M:%S&#39;) for item in indices]
        anomalies[column] =  list(set(indices))


    return anomalies</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.following_error_drop_dict"><code class="name flex">
<span>def <span class="ident">following_error_drop_dict</span></span>(<span>self, following: dict, previous_data: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine following anomalies with their corresponding drop values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>following</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing following anomalies.</dd>
<dt><strong><code>previous_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing previous data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing following anomalies with drop values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def following_error_drop_dict(self,following : dict,previous_data: dict):
    &#34;&#34;&#34;Combine following anomalies with their corresponding drop values.

    Args:
        following (dict): A dictionary containing following anomalies.
        previous_data (dict): A dictionary containing previous data.

    Returns:
        dict: A dictionary containing following anomalies with drop values.
    &#34;&#34;&#34;
    result_dict = {}
    for key in following.keys():
        result_dict[key] = {}
        for time_key, value in following[key].items():
            str_time_key = self.convert_time_to_str(time_key)
            result_dict[key][str_time_key] = {&#39;previous&#39;: value}

        for time_key, value in previous_data[key].items():
            if isinstance(time_key, str) == False: 
                time_key = self.convert_time_to_str(time_key)
            str_time_key = time_key
            if str_time_key not in result_dict[key]:
                result_dict[key][str_time_key] = {}
            result_dict[key][str_time_key][&#39;drop&#39;] = value
    return result_dict</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.prettier_following_drop"><code class="name flex">
<span>def <span class="ident">prettier_following_drop</span></span>(<span>self, result_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Print following anomalies with drop values in a prettier format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>result_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing following anomalies with drop values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prettier_following_drop(self,result_dict):
    &#34;&#34;&#34;Print following anomalies with drop values in a prettier format.

    Args:
        result_dict (dict): A dictionary containing following anomalies with drop values.

    Returns:
        None
    &#34;&#34;&#34;
    for key, data in result_dict.items():
        print(f&#34;\n{key} data:&#34;)
        print(&#34;{:&lt;12} {:&lt;10} {:&lt;10} {:&lt;10}&#34;.format(&#39;Time&#39;, &#39;End_time&#39; ,&#39;Previous&#39;, &#39;Drop&#39;))
        for time_key, values in data.items():
            print(&#34;{:&lt;12} {:&lt;10} {:&lt;10} {:&lt;10}&#34;.format(
                time_key, self.add_minutes_to_time(time_key, values.get(&#39;previous&#39;, &#39;&#39;) ) , values.get(&#39;previous&#39;, &#39;&#39;), values.get(&#39;drop&#39;, &#39;&#39;)
            ))</code></pre>
</details>
</dd>
<dt id="projet.verification.Verification.save_following_drop_csv"><code class="name flex">
<span>def <span class="ident">save_following_drop_csv</span></span>(<span>result_dict: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Save following anomalies with drop values to a CSV file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>result_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing following anomalies with drop values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_following_drop_csv(result_dict: dict):
    &#34;&#34;&#34;Save following anomalies with drop values to a CSV file.

    Args:
        result_dict (dict): A dictionary containing following anomalies with drop values.
    &#34;&#34;&#34;
    for key, data in result_dict.items():
        csv_filename = f&#34;{key}_data.csv&#34;
        with open(csv_filename, &#39;w&#39;, newline=&#39;&#39;) as csvfile:
            fieldnames = [&#39;time&#39;, &#39;previous&#39;, &#39;drop&#39;]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()

            for time_key, values in data.items():
                writer.writerow({
                    &#39;time&#39;: time_key,
                    &#39;previous&#39;: values.get(&#39;previous&#39;, &#39;&#39;),
                    &#39;drop&#39;: values.get(&#39;drop&#39;, &#39;&#39;)
                })

        print(f&#34;CSV file &#39;{csv_filename}&#39; created successfully.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="projet" href="index.html">projet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="projet.verification.remove_zscore_key_word" href="#projet.verification.remove_zscore_key_word">remove_zscore_key_word</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="projet.verification.Verification" href="#projet.verification.Verification">Verification</a></code></h4>
<ul class="">
<li><code><a title="projet.verification.Verification.add_minutes_to_time" href="#projet.verification.Verification.add_minutes_to_time">add_minutes_to_time</a></code></li>
<li><code><a title="projet.verification.Verification.convert_time_to_str" href="#projet.verification.Verification.convert_time_to_str">convert_time_to_str</a></code></li>
<li><code><a title="projet.verification.Verification.day_analyze_and_print_results" href="#projet.verification.Verification.day_analyze_and_print_results">day_analyze_and_print_results</a></code></li>
<li><code><a title="projet.verification.Verification.day_anomalie_slope" href="#projet.verification.Verification.day_anomalie_slope">day_anomalie_slope</a></code></li>
<li><code><a title="projet.verification.Verification.day_following_timestamps" href="#projet.verification.Verification.day_following_timestamps">day_following_timestamps</a></code></li>
<li><code><a title="projet.verification.Verification.day_mean_analyze_and_print_results" href="#projet.verification.Verification.day_mean_analyze_and_print_results">day_mean_analyze_and_print_results</a></code></li>
<li><code><a title="projet.verification.Verification.day_mean_anomalie_slope" href="#projet.verification.Verification.day_mean_anomalie_slope">day_mean_anomalie_slope</a></code></li>
<li><code><a title="projet.verification.Verification.day_mean_zscore_verification" href="#projet.verification.Verification.day_mean_zscore_verification">day_mean_zscore_verification</a></code></li>
<li><code><a title="projet.verification.Verification.day_z_score_verification" href="#projet.verification.Verification.day_z_score_verification">day_z_score_verification</a></code></li>
<li><code><a title="projet.verification.Verification.following_error_drop_dict" href="#projet.verification.Verification.following_error_drop_dict">following_error_drop_dict</a></code></li>
<li><code><a title="projet.verification.Verification.prettier_following_drop" href="#projet.verification.Verification.prettier_following_drop">prettier_following_drop</a></code></li>
<li><code><a title="projet.verification.Verification.save_following_drop_csv" href="#projet.verification.Verification.save_following_drop_csv">save_following_drop_csv</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>